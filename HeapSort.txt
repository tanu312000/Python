import math
def max_heapify(A,currentNode):
    print(currentNode)
    left=2*currentNode+1
    right=2*currentNode+2
    largest=currentNode

    if(left<=len(A)-1 and A[left]>A[currentNode]):
        largest=left


    if(right<=len(A)-1 and A[right] > A[largest]):
        largest=right

    if(largest!=currentNode):
        temp=A[currentNode]
        A[currentNode]=A[largest]
        A[largest]=temp
        max_heapify(A, largest)






def Build_max_heapify(A):
    for i in range(math.floor(((len(A))/2)-1),-1,-1):
        max_heapify(A,i)

def heap_extract_max(A):
    if len(A)<0:
        Error="Heap Underflow"
    max=A[0]
    A[0]=A[len(A)-1]
    max_heapify(A,0)
    return max

def heap_increase_key(A,node,value):
    if(value<A[node]):
        print("Error")
    A[node]=value
    parentNode=math.floor((node-1)/2)
    while(node>0 and A[parentNode] < A[node]):
        temp=A[node]
        A[node]=A[parentNode]
        A[parentNode]=temp

        node=parentNode
        parentNode = math.floor((node - 1) / 2)


